const Docker = require('dockerode');

/**
 * Docker Container driver
 * 
 * Handles the creation and deletation of containers to back Projects
 * 
 * This driver creates Projects backed by Docker 
 * 
 * @module docker
 * @memberof forge.containers.drivers
 * 
 */
module.exports = {
     /**
     * Initialises this driver
     * @param {string} app - the Vue application 
     * @param {object} options - A set of configuration options for the driver
     * @return {forge.containers.ProjectArguments}
     */
    init: async (app, options) => {
        this._app = app
        this._docker = new Docker({
            socketPath: process.env.DOCKER_SOCKET || '/var/run/docker.sock'
        })
        this._options = options

        require('./models/Project')(app.db)

        let projects = await this._app.db.models.DockerProject.findAll()
        projects.forEach(async (project) => {
            let container = await this._docker.getContainer(project.id)
            if (container) {
                let state = await container.inspect()
                if (!state.State.Running) {
                    if (project.state == 'running') {
                        //need to restart existing container
                        container.start()
                    }
                } 
            } else {
                //need to create
                let p = await this._app.dn.models.Project.byId(project.id)
                let name = p.name
                this._app.containers._createContainer(project.id,
                    JSON.parse(project.options),
                    this._options.domain, 
                    this._options.containers[project.type]
                );
            }
        })

        return {}
    },
    /**
     * Create a new Project
     * @param {string} id - id for the project
     * @param {forge.containers.Options} options - options for the project
     * @return {forge.containers.Project}
     */
    create: async (id, options) => {
        console.log("creating ", id)
        // console.log(options)
        // console.log("---")

        return await this._app.containers._createContainer(id, options, this._options.domain, this._options.containers[options.type])
    },
    /**
     * Removes a Project
     * @param {string} id - id of project to remove
     * @return {Object}
     */
    remove: async (id) => {
        console.log("removing ", id)
        try {
            let container = await this._docker.getContainer(id);
            await container.stop()
            await container.remove()
            let project = await this._app.db.models.DockerProject.byId(id)
            await project.destroy()
            return {status: "okay"}
        } catch (err) {
            return {error: err}
        }
    },
    /**
     * Retrieves details of a project's container
     * @param {string} id - id of project to query
     * @return {Object} 
     */
    details: async (id) => {
        try {
            let container = await this._docker.getContainer(id);
            return container
        } catch (err) {
            return {error: err}
        }
    },
    /**
     * Lists all containers
     * @param {string} filter - rules to filter the containers
     * @return {Object}
     */
    list: async (filter) => {
        let containers = await this._docker.listContainers({all: true})
        //console.log(containers)
        return containers.map(c => { return c.Names[0].substring(1)})
    },
    /**
     * Starts a Project's container
     * @param {string} id - id of project to start
     * @return {forge.Status}
     */
    start: async (id) => {
        try {
            let container = await this._docker.getContainer(id);
            container.start()
        } catch (err) {

        }
    },
    /**
     * Stops a Proejct's container
     * @param {string} id - id of project to stop
     * @return {forge.Status}
     */
    stop: async (id) => {
        try {
            let container = await this._docker.getContainer(id);
            container.stop()
        } catch (err) {

        }
    },
    /**
     * Restarts a Project's container
     * @param {string} id - id of project to restart
     * @return {forge.Status}
     */
    restart: async (id) => {
        await this.stop(id);
        return await this.start(id);
    },
    _createContainer: async (id, options, domain, image) => {

        let contOptions = {
            Image: image,
            name: id,
            Env: [],
            Labels: {},
            AttachStdin: false,
            AttachStdout: false,
            AttachStderr: false,
            HostConfig: {
                NetworkMode: "internal"
            }
        }
        if (options.env) {
            Object.keys(options.env).forEach(k=>{
                if (k) {
                    contOptions.Env.push(k+"="+options.env[k])
                }
            })
        }

        //AuthProvider
        contOptions.Env.push("FORGE_CLIENT_ID="+options.clientID);
        contOptions.Env.push("FORGE_CLIENT_SECRET="+options.clientSecret);
        //TODO this needs to come from a central point
        contOptions.Env.push("FORGE_URL="+process.env["BASE_URL"]);
        //TODO this needs to dynamic (and deal with http vs https)
        contOptions.Env.push(`BASE_URL=http://${options.name}.${domain}`);
        contOptions.Env.push(`VIRTUAL_HOST=${options.name}.${domain}`);

        try {
            let container = await this._docker.createContainer(contOptions);
            let project = await this._app.db.models.DockerProject.create({
                id: id,
                url: `https://${options.name}.${domain}`,
                state: "starting",
                options: options ? JSON.stringify(options) : '{}'
            })
            container.start()
            .then(() => {
                project.state = "running";
                project.save();
            });

            return {
                id: id, 
                status: "okay", 
                    url: `https://${options.name}.${this._options.domain}`,
                meta: container
            };
        } catch(err) {
            return {error: err}
        }
    }
}