const k8s = require('@kubernetes/client-node');

/**
 * Kubernates Container driver
 * 
 * Handles the creation and deletation of containers to back Projects
 * 
 * This driver creates Projects backed by Kubernates 
 * 
 * @module kubernates
 * @memberof forge.containers.drivers
 * 
 */

const podTemplate = {
  apiVersion: "v1",
  kind: "Pod",
  metadata: {
    // name: "k8s-client-test",
    labels: {
      // name: "k8s-client-test",
      nodered: "true"
      // app: "k8s-client-test",
      // "pts-node-red": "bronze"
    }   
  },
  spec: {
    containers: [
      {
        name: "node-red",
        // image: "docker-pi.local:5000/bronze-node-red",
        env:[
          // {name: "APP_NAME", value: "test"},
          {name: "MONGO_URL", value: "mongodb://mongo.default:27017/nodered"},
          {name: "TZ", value: "Europe/London"}
        ],
        ports:[
          {name: "web", containerPort: 1880, protocol: "TCP"}
        ]
      }
    ]
  },
  enableServiceLinks: false
}

const deploymentTemplate = {
  apiVersion: "apps/v1",
  kind: "Deployment",
  metadata: {
    // name: "k8s-client-test-deployment",
    labels: {
      // name: "k8s-client-test-deployment",
      nodered: "true"
      // app: "k8s-client-test-deployment"
    }
  },
  spec: {
    replicas: 1,
    selector: {
      matchLabels: {
        // app: "k8s-client-test-deployment"
      }
    },
    template: {
      metadata: {
        labels: {
          // name: "k8s-client-test-deployment",
          nodered: "true"
          // app: "k8s-client-test-deployment"
        }
      },
      spec: {
        containers: [
          {
            name: "node-red",
            // image: "docker-pi.local:5000/bronze-node-red",
            env: [
              // {name: "APP_NAME", value: "test"},
              {name: "MONGO_URL", value: "mongodb://mongo.default:27017/nodered"},
              {name: "TZ", value: "Europe/London"}
            ],
            ports: [
              {name: "web", containerPort: 1880, protocol: "TCP"}
            ]
          }
        ]
      },
      enableServiceLinks: false
    }
  }
}

const serviceTemplate = {
  apiVersion: "v1",
  kind: "Service",
  metadata: {
    // name: "k8s-client-test-service"
  },
  spec: {
    type: "NodePort",
    selector: {
      //name: "k8s-client-test"
    },
    ports: [
      { port: 1880, protocol: "TCP" }
    ]
  }
}

const ingressTemplate = {
  apiVersion: "networking.k8s.io/v1",
  kind: "Ingress",
  metadata: {
    // name: "k8s-client-test-ingress",
    namespace: "flowforge"
  },
  spec: {
    rules: [
      {
        // host: "k8s-client-test" + "." + "ubuntu.local",
        http: {
          paths: [
            {
              pathType: "Prefix",
              path: "/",
              backend: {
                service: {
                  name: "k8s-client-test-service",
                  port: { number: 1880 }
                }
              }
            }
          ]
        }
      }
    ]
  }
}

module.exports = {
  /**
   * Initialises this driver
   * @param {string} app - the Vue application 
   * @param {object} options - A set of configuration options for the driver
   * @return {forge.containers.ProjectArguments}
   */
  init: async (app, options) => {
    this._app = app;
    this._options = options;
    const kc = new k8s.KubeConfig();

    require('./models/Project')(app.db)

    let configFile = process.env.KUBE_CONFIG_FILE || ""

    if (configFile) {
      kc.loadFromFile(configFile);
    } else {
      // try and load defaults
      kc.loadFromDefault();
      // else need to log error
    }

    // if (this._options.configFile) {
    //   kc.loadFromFile(this._options.configFile);
    // else if (this._options.config && typeof ths._options.config === 'string') {
    //   kc.loadFromString(this._options.config);
    // else if (this._options.config && typeof ths._options.config === 'Object') {
    //   kc.loadFromOptions(this._options.config);
    // } else {
    //   kc.loadFromDefault();
    // }
    
    this._k8sApi = kc.makeApiClient(k8s.CoreV1Api);
    this,_k8sAppApi = kc.makeApiClient(k8s.AppsV1Api);
    this._k8sNetApi = kc.makeApiClient(k8s.NetworkingV1Api);

    //need to work out what we can expose for K8s
    return {}

  },
  /**
   * Create a new Project
   * @param {string} id - id for the project
   * @param {forge.containers.Options} options - options for the project
   * @return {forge.containers.Project}
   */
  create: async (id, options) => {
    let localPod = JSON.parse(JSON.stringify(podTemplate))
    localPod.metadata.name = options.name;
    localPod.metadata.labels.name = options.name;
    localPod.metadata.labels.app = id;
    localPod.spec.containers[0].image = this._options.containers[options.type];
    if (options.env) {
      Object.keys(options.env).forEach(k => {
        if (k) {
          localPod.spec.containers[0].env.push({
            name: k,
            value: options.env[k]
          })
        }
      })
    }

    localPod.spec.containers[0].env.push({name: "FORGE_CLIENT_ID", value: options.clientID});
    localPod.spec.containers[0].env.push({name: "FORGE_CLIENT_SECRET", value: options.clientSecret});
    localPod.spec.containers[0].env.push({name: "FORGE_URL", value: process.env["BASE_URL"]});
    localPod.spec.containers[0].env.push({name: "BASE_URL", value: `http://${options.name}.${this._options.domain}`});

    let localService = JSON.parse(JSON.stringify(serviceTemplate));
    localService.metadata.name = options.name;
    localService.spec.selector.name = options.name;

    let localIngress = JSON.parse(JSON.stringify(ingressTemplate));
    localIngress.metadata.name = options.name;
    localIngress.spec.rules[0].host = options.name + "." + this._options.domain;
    localIngress.spec.rules[0].http.paths[0].backend.service.name = options.name;

    try {
        await this._k8sApi.createNamespacedPod('flowforge', localPod)
        // .then(() => {
          // return 
          await this._k8sApi.createNamespacedService('flowforge', localService)
        // })
        // .then(() => {
          // return 
          await this._k8sNetApi.createNamespacedIngress('flowforge', localIngress)
        // })
        
    } catch (err) {
      console.log(err)
      return {error: err}
    }

    await this._app.db.models.K8SProject.create({
      id: id,
      //TODO http/https needs to be dynamic (or we just enforce https?)
      url: `http://${options.name}.${this._options.domain}`,
      state: "running",
      env: options.env ? JSON.stringify(options.env): '{}'
    })

    return {
      id: id,
      status: "okay",
      url: `https://${options.name}.${this._options.domain}`,
      meta: {}
    }
  },
  /**
   * Removes a Project
   * @param {string} id - id of project to remove
   * @return {Object}
   */
  remove: async (id) => {

    let project = await this._app.db.models.Project.byId(id)

    let promises = []

    promises.push(this._k8sNetApi.deleteNamespacedIngress(project.name, 'flowforge'))
    promises.push(this._k8sApi.deleteNamespacedService(project.name, 'flowforge'))
    promises.push(this._k8sApi.deleteNamespacedPod(project.name, 'flowforge'))

    try {
      let results = await Promise.all(promises)

      let project = await this._app.db.models.K8SProject.byId(id);
      project.destroy();

      return {
        status: "okay"
      }
    } catch (err) {
      return {
        error: err
      }
    }
    
  },
  /**
   * Retrieves details of a project's container
   * @param {string} id - id of project to query
   * @return {Object} 
   */
  details: async (id) => {
    try {
      let details = await this._k8sApi.readNamespacePod(id, 'flowforge')
      //really need to cull this
      return details
    } catch (err) {
      return {error: err}
    }
  },
  /**
   * Lists all containers
   * @param {string} filter - rules to filter the containers
   * @return {Object}
   */
  list: async (filter) => {
    this._k8sApi.listNamespacedPod('flowforge',undefined, undefined, undefined, undefined,"nodered=true")
    .then((pods) => {
      //Turn this into a standard form
    })
  },
  /**
   * Starts a Project's container
   * @param {string} id - id of project to start
   * @return {forge.Status}
   */
  start: async (id) => {
    //there is no concept of start/stop in Kubernetes
  },
  /**
   * Stops a Proejct's container
   * @param {string} id - id of project to stop
   * @return {forge.Status}
   */
  stop: async (id) => {
    //there is no concept of start/stop in Kubernetes
  },
  /**
   * Restarts a Project's container
   * @param {string} id - id of project to restart
   * @return {forge.Status}
   */
  restart: async (id) => {
    //This needs the container killing
    this._k8sApi.replaceNamespacedPod(id, 'flowforge')
  }
}