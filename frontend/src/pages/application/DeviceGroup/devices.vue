<template>
    <main v-if="!deviceGroup?.id">
        <ff-loading message="Loading Device Group..." />
    </main>
    <div v-else class="w-full" data-el="device-group-devices">
        <div class="mb-3">
            <SectionTopMenu hero="Device Group Membership" info="">
                <template #tools>
                    <div v-if="!editMode && !hasChanges" class="flex flex-wrap justify-end items-end gap-x-2 gap-y-2 mt-0 mb-1">
                        <ff-button
                            :disabled="!hasPermission('application:device-group:update', {application})"
                            data-action="edit-device-group"
                            kind="primary" size="small" class="w-24 whitespace-nowrap" @click="editMode = true"
                        >
                            Edit
                        </ff-button>
                    </div>
                    <div v-else class="flex flex-wrap justify-end items-end gap-x-2 gap-y-2 mt-0 mb-1">
                        <ff-button kind="secondary" size="small" class="w-24 whitespace-nowrap" @click="cancelChanges">Cancel</ff-button>
                        <ff-button kind="primary" size="small" :disabled="!hasChanges" class="w-24 whitespace-nowrap" @click="saveChanges">Save Changes</ff-button>
                    </div>
                </template>
            </SectionTopMenu>
        </div>

        <div class="flex flex-col sm:flex-row">
            <div v-if="editMode" class="w-full sm:w-1/2 order-3 sm:order-1">
                <div class="flex justify-between items-center mb-1">
                    <h3 class="text-gray-800 block text-sm font-medium mb-1 min-w-0 truncate">Available devices</h3>
                    <ff-button
                        size="small" class="w-28 whitespace-nowrap mb-1"
                        :disabled="!selectedAvailableDevices.length || !hasPermission('application:device-group:create', {application})"
                        @click="addDevicesToGroup()"
                    >
                        Add Devices
                    </ff-button>
                </div>
                <ff-data-table
                    :columns="tableColsRW"
                    :show-search="true"
                    search-placeholder="Search..."
                    no-data-message="No Devices available"
                    @update:search="updateAvailableDeviceListDebounced"
                    @update:sort="updateAvailableDevicesSort"
                >
                    <template #rows>
                        <ff-data-table-row v-for="device in availableDevices" :key="device">
                            <ff-data-table-cell>
                                <ff-checkbox v-model="device.selected" />
                            </ff-data-table-cell>
                            <ff-data-table-cell>
                                <router-link :to="{name: 'DeviceOverview', params: {id: device.id}}">{{ device.name }}</router-link>
                            </ff-data-table-cell>
                            <ff-data-table-cell>{{ device.type }}</ff-data-table-cell>
                        </ff-data-table-row>
                    </template>
                </ff-data-table>
            </div>
            <div v-if="editMode" class="w-1 border-l border-gray-300 pl-4 ml-4 hidden sm:block order-2" />
            <div v-if="editMode" class="w-full border-t border-gray-300 pb-4 mt-4 sm:hidden order-2" />
            <div :class="editMode ? 'w-full sm:w-1/2 order-1 sm:order-3' : 'w-full'">
                <div v-if="editMode" class="flex justify-between items-center mb-1">
                    <!-- <h2 class="text-xl font-bold min-w-0 truncate">{{ deviceGroup.name }}</h2> -->
                    <h3 class="text-gray-800 block text-sm font-medium mb-1 min-w-0 truncate">Group Members</h3>
                    <ff-button size="small" class="w-28 whitespace-nowrap mb-1" :disabled="!selectedMemberDevices.length" @click="removeDevicesFromGroup()">Remove Devices</ff-button>
                </div>

                <ff-data-table
                    :columns="editMode ? tableColsRW : tableColsRO"
                    :show-search="true"
                    search-placeholder="Search..."
                    :no-data-message="localMemberDevices?.length ? 'No Devices found, try another search term' : 'No Devices assigned to this group'"
                    data-el="device-group-members"
                    @update:search="updateMemberDevicesListDebounced"
                    @update:sort="updateMemberDevicesSort"
                >
                    <template #rows>
                        <ff-data-table-row v-for="device in memberDevices" :key="device">
                            <ff-data-table-cell v-if="editMode">
                                <ff-checkbox v-model="device.selected" class="inline" />
                            </ff-data-table-cell>
                            <ff-data-table-cell class="w-1/3">
                                <router-link :to="{name: 'DeviceOverview', params: {id: device.id}}">{{ device.name }}</router-link>
                            </ff-data-table-cell>
                            <ff-data-table-cell class="w-1/3">{{ device.name }}</ff-data-table-cell>
                            <ff-data-table-cell v-if="!editMode" class="w-1/3">
                                <ActiveSnapshotCell :activeSnapshot="getDeviceActiveSnapshot(device)" :targetSnapshot="targetSnapshot" />
                            </ff-data-table-cell>
                        </ff-data-table-row>
                    </template>
                </ff-data-table>
            </div>
        </div>
    </div>
</template>

<script>
import { h } from 'vue'
import { mapState } from 'vuex'

import ApplicationApi from '../../../api/application.js'
import SectionTopMenu from '../../../components/SectionTopMenu.vue'
import DeployNotice from '../../../components/notices/device-groups/DeployNotice.vue'
import usePermissions from '../../../composables/Permissions.js'

import Alerts from '../../../services/alerts.js'
import Dialog from '../../../services/dialog.js'

import { debounce } from '../../../utils/eventHandling.js'

import ActiveSnapshotCell from '../components/cells/Snapshot.vue'

export default {
    name: 'DeviceGroupDevices',
    components: {
        ActiveSnapshotCell,
        SectionTopMenu
    },
    inheritAttrs: false,
    props: {
        application: {
            type: Object,
            required: true
        },
        applicationDevices: {
            type: Array,
            required: true
        },
        deviceGroup: {
            type: Object,
            required: true
        }
    },
    emits: ['device-group-members-updated', 'device-group-updated'],
    setup () {
        const { hasPermission } = usePermissions()
        return { hasPermission }
    },
    data: function () {
        return {
            localMemberDevices: [],
            localAvailableDevices: [],
            availableDevices: [],
            memberDevices: [],
            availableSearchTerm: '',
            membersSearchTerm: '',
            hasChanges: false,
            editMode: false,
            memberDevicesSort: {
                key: null,
                direction: 'desc'
            },
            availableDevicesSort: {
                key: null,
                direction: 'desc'
            },
            tableColsRO: [
                { label: 'Name', key: 'name', sortable: true, class: 'w-1/3' },
                { label: 'Type', key: 'type', sortable: true, class: 'w-1/3' },
                { label: 'Active Snapshot', key: 'type', sortable: true, class: 'w-1/3' }
            ],
            tableColsRW: [
                { label: '', key: 'selected', sortable: true },
                { label: 'Name', key: 'name', sortable: true, class: 'w-1/3' },
                { label: 'Type', key: 'type', sortable: true, class: 'w-2/3' }
            ]
        }
    },
    computed: {
        ...mapState('account', ['team', 'teamMembership']),
        selectedAvailableDevices () {
            return this.localAvailableDevices.filter((device) => device.selected)
        },
        selectedMemberDevices () {
            return this.localMemberDevices.filter((device) => device.selected)
        },
        targetSnapshot () {
            return this.deviceGroup?.targetSnapshot || null
        }
    },
    watch: {
        'application.id': 'loadDevices',
        'deviceGroup.id': 'loadDevices',
        applicationDevices: 'loadDevices'
    },
    mounted () {
        this.loadDevices()
    },
    methods: {
        async loadDevices () {
            this.initLocalData()
            // set this.availableDevices to a copy of the availableDevices array but with a selected property
            this.updateAvailableDeviceList()
            this.updateMemberDevicesList()
        },
        initLocalData () {
            this.localMemberDevices = (this.deviceGroup?.devices || []).map((device) => {
                return {
                    id: device.id,
                    name: device.name,
                    type: device.type,
                    selected: false
                }
            }) || []
            const ungrouped = this.applicationDevices.filter((device) => !device.deviceGroup)
            this.localAvailableDevices = ungrouped?.map((device) => {
                return {
                    id: device.id,
                    name: device.name,
                    type: device.type,
                    selected: false
                }
            }) || []
        },
        updateAvailableDeviceListDebounced: debounce(function (availableSearchTerm) {
            this.updateAvailableDeviceList(availableSearchTerm)
        }, 350),
        updateAvailableDeviceList (availableSearchTerm) {
            if (arguments.length) {
                this.availableSearchTerm = availableSearchTerm
            }
            let tempList
            // if no search term, simply set the available devices to the filtered list
            if (!this.availableSearchTerm) {
                tempList = this.localAvailableDevices
            } else {
                // there is a search term, filter the available devices
                const term = this.availableSearchTerm.toLowerCase()
                tempList = this.localAvailableDevices.filter((device) => {
                    return device.name.toLowerCase().includes(term) || device.type?.toLowerCase().includes(term)
                })
            }
            this.availableDevices = this.sortList(tempList, this.availableDevicesSort)
            // compare this.deviceGroup.devices -to- this.memberDevices
            // if they are different, set this.hasChanges to true
            const originalMembers = this.deviceGroup?.devices || []
            if (originalMembers.length !== this.localMemberDevices.length) {
                this.hasChanges = true
                return
            }
            const localMembersIds = this.localMemberDevices.map((device) => device.id)
            const originalMembersIds = originalMembers.map((device) => device.id)
            this.hasChanges = !localMembersIds.every((id) => originalMembersIds.includes(id))
        },
        updateMemberDevicesListDebounced: debounce(function (membersSearchTerm) {
            this.updateMemberDevicesList(membersSearchTerm)
        }, 350),
        updateMemberDevicesList (membersSearchTerm) {
            if (arguments.length) {
                this.membersSearchTerm = membersSearchTerm || ''
            }
            let tempList
            // if no search term, simply set the member devices to the filtered list
            if (!this.membersSearchTerm) {
                tempList = this.localMemberDevices
            } else {
                // there is a search term, filter the member devices
                const term = this.membersSearchTerm.toLowerCase()
                tempList = this.localMemberDevices.filter((device) => {
                    return device.name.toLowerCase().includes(term) || device.type?.toLowerCase().includes(term)
                })
            }
            this.memberDevices = this.sortList(tempList, this.memberDevicesSort)
        },
        async loadMoreDevices () {
            // await this.fetchDevices()
        },
        addDevicesToGroup () {
            // get the selected devices from the available devices list
            const selectedDevices = this.localAvailableDevices.filter((device) => device.selected)
            this.localMemberDevices.push(...selectedDevices)
            this.localAvailableDevices = this.localAvailableDevices.filter((device) => !device.selected)
            this.updateAvailableDeviceList()
            this.updateMemberDevicesList()
        },
        removeDevicesFromGroup () {
            // get the selected devices from the member devices list
            const selectedDevices = this.localMemberDevices.filter((device) => device.selected)
            const selectedDeviceIds = selectedDevices.map((device) => device.id)
            this.localMemberDevices = this.localMemberDevices.filter((device) => !device.selected)
            this.localAvailableDevices.push(...selectedDevices)
            this.updateAvailableDeviceList()
            this.updateMemberDevicesList()
            // now select the devices in the available devices list that were just removed from the member devices list
            this.availableDevices.forEach((device) => {
                if (selectedDeviceIds.includes(device.id)) {
                    device.selected = true
                }
            })
        },
        updateAvailableDevicesSort (key, direction) {
            this.availableDevicesSort.key = key
            this.availableDevicesSort.direction = direction
            this.updateAvailableDeviceList()
        },
        updateMemberDevicesSort (key, direction) {
            this.memberDevicesSort.key = key
            this.memberDevicesSort.direction = direction
            this.updateMemberDevicesList()
        },
        sortList (list, sorting) {
            if (!sorting.key) {
                return list
            }

            const key = sorting.key
            const direction = sorting.direction === 'asc' ? 1 : -1

            return list.sort((a, b) => {
                const aVal = a[key] || ''
                const bVal = b[key] || ''

                if (aVal < bVal) {
                    return -1 * direction
                } else if (aVal > bVal) {
                    return 1 * direction
                } else {
                    return 0
                }
            })
        },
        cancelChanges () {
            this.initLocalData()
            this.updateAvailableDeviceList()
            this.updateMemberDevicesList()
            this.editMode = false
        },
        async saveChanges () {
            const deviceIds = this.localMemberDevices.map((device) => device.id)
            const devicesRemoved = this.deviceGroup.devices.filter((device) => this.localAvailableDevices.map((d) => d.id).includes(device.id))
            const devicesAdded = this.localMemberDevices.filter((device) => !this.deviceGroup.devices.map((d) => d.id).includes(device.id))
            const removedCount = devicesRemoved.length
            const addedCount = devicesAdded.length
            const text = []
            const notices = []
            if (addedCount > 0) {
                text.push('<h2>One or more devices will be added to this group.</h2>')
                if (this.deviceGroup.targetSnapshot?.id) {
                    const component = h(DeployNotice, {
                        targetSnapshot: this.deviceGroup.targetSnapshot
                    })
                    notices.push(component)
                }
            }
            if (removedCount > 0) {
                text.push('<h2>1 or more devices will be removed from this group.</h2>')
                notices.push(`${removedCount > 1 ? 'These devices' : 'This device'} will be cleared of any active pipeline snapshot.`)
            }
            if (addedCount <= 0 && removedCount <= 0) {
                return // nothing to do, shouldn't be able to get here as the save button should be disabled. but just in case...
            }

            text.push('<p class="!mt-5">Do you want to continue?</p>')

            const html = text.join('\n')

            Dialog.show({
                header: 'Update device group members',
                kind: 'danger',
                html,
                notices,
                confirmLabel: 'Confirm',
                cancelLabel: 'No'
            }, async () => {
                ApplicationApi.updateDeviceGroupMembership(this.application.id, this.deviceGroup.id, { set: deviceIds })
                    .then(() => {
                        Alerts.emit('Device Group updated.', 'confirmation')
                        this.hasChanges = false
                        this.$emit('device-group-members-updated')
                        this.editMode = false
                        if (deviceIds.length === 0 && this.deviceGroup.targetSnapshot) {
                            Dialog.show({
                                header: 'Empty Device Group',
                                kind: 'danger',
                                text: 'Do you want to clear the Target Snapshot for this empty Device Group?',
                                confirmLabel: 'Clear',
                                cancelLabel: 'No'
                            }, async () => {
                                try {
                                    const response = await ApplicationApi.updateDeviceGroup(this.application.id, this.deviceGroup.id, undefined, undefined, null)
                                    if (response.status === 200) {
                                        this.$emit('device-group-updated')
                                        Alerts.emit('Device Group Target Snapshot was cleared', 'confirmation')
                                    } else {
                                        Alerts.emit('Failed to clear the Target Snapshot', 'warning', 5000)
                                    }
                                } catch (error) {
                                    const msg = error.response?.data?.error || 'Error clearing device groups Target Snapshot'
                                    Alerts.emit(msg, 'warning', 5000)
                                }
                            })
                        }
                    })
                    .catch((err) => {
                        Alerts.emit('Failed to update Device Group: ' + err.toString(), 'warning')
                        console.error(err)
                    })
            })
        },
        getDeviceActiveSnapshot (device) {
            if (!device?.id) {
                return null
            }
            const appDevice = this.applicationDevices?.find((d) => d.id === device.id)
            return appDevice?.activeSnapshot || null
        }
    }
}
</script>
